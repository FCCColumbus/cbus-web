import { render } from "@testing-library/react";

import App from "../App";

jest.mock('../components/Header', () => () => "HeaderMock");
jest.mock('../components/Splash', () => () => "SplashMock");
jest.mock('../components/About', () => () => "AboutMock");
jest.mock('../components/Events', () => () => "EventsMock");
jest.mock('../components/Members', () => () => "MembersMock");
jest.mock('../components/Footer', () => () => "FooterMock");

describe("App", () => {
  test("renders App components in order", () => {
    // Capture the raw output of the render function.
    // It returns a data type called "RenderResult", so that's what we'll name the variable.
    const renderResult = render(<App />);

    // Isolate the thing that we want to test.
    // I usually name this variable "actual" as it represents what our code is actually doing,
    // and is consistent with the "actual-expected" terminology used in unit testing.
    // In this case, our RenderResult object has a property called "container" and we want to test
    // the innerHTML of that container.
    // In the context of React/JSX, the innerHTML is what's generated by the component's return statement.
    const actual = renderResult.container.innerHTML;

    const expected = "<div class=\"App\">HeaderMockSplashMockAboutMockEventsMock<img src=\"/divider.jpg\" alt=\"code on a screen. mostly css\">MembersMockFooterMock</div>";
    expect(actual).toBe(expected)
  });
});
